#! /usr/bin/env ruby

require 'rubygems'
require 'optparse'

OptionParser.new do |opts|
  opts.banner = <<BANNER
Find the commit that broke the build

Usage:
    git-autobisect 'ruby test/foo_test.rb -n "/xxx/"' [options]

Options:
BANNER
  opts.on("-h", "--help","Show this.") { puts opts; exit }
  opts.on("-v", "--version","Show Version"){
    version = File.read(File.expand_path("../../VERSION", __FILE__))
    puts "git-autobisect #{version}"; exit
  }
end.parse!

command = ARGV.first
if command.to_s.empty?
  puts "Usage instructions: git-autobisect --help"
  exit
end

def run(cmd)
  all = ""
  puts cmd
  IO.popen(cmd) do |pipe|
    while str = pipe.gets
      all << str
      puts str
    end
  end
  [$?.success?, all]
end

def run!(command)
  raise "Command failed #{command}" unless run(command).first
end

def find_first_good_commit(commits, command)
  i = 0

  loop do
    # scan backwards through commits to find a good
    offset = 2**i - 1
    maybe_good, bad = commits[offset], (maybe_good || commits.first)
    return unless maybe_good

    # see if it works
    puts " ---> Now trying #{maybe_good} (HEAD~#{offset})"
    run!("git checkout #{maybe_good}")
    return [maybe_good, bad] if run(command).first
    i += 1
  end
end

def bisect_to_exact_match(command, good, bad)
  run! "git bisect reset"
  run! "git bisect start"
  run! "git checkout #{bad}"
  run! "git bisect bad"
  run! "git checkout #{good}"
  run! "git bisect good"
  success, output = run("git bisect run sh -c '#{command}'")
  raise "error while bisecting" unless success
  output.match(/([\da-f]+) is the first bad commit/)[1]
end

def exact_commit_known?(commits, good, bad)
  (commits.index(good) - commits.index(bad)).abs <= 1
end

max_commits = 1000
command = "(bundle check || bundle) && (#{command})" if File.exist?("Gemfile")
commits = `git log --pretty=format:'%h' | head -n #{max_commits}`.split("\n")
good, bad = find_first_good_commit(commits, command)

if good == commits.first
  puts " ---> HEAD is not broken"
  exit 1
elsif not good
  puts " --> No good commit found"
  exit 1
end

if exact_commit_known?(commits, good, bad)
  # return same result as git bisect
  run "git checkout #{bad}"
  puts "#{bad} is the first bad commit"
  puts `git show #{bad}`
else
  first_bad = bisect_to_exact_match(command, good, bad)
  run! "git checkout #{first_bad}"
end
